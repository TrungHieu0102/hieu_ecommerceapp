import { isArray } from './common-utils';
/* eslint-disable @typescript-eslint/ban-types */
export class BaseTreeNode {
    constructor(props) {
        this.children = [];
        this.isLeaf = true;
        Object.assign(this, props);
    }
    static create(props) {
        return new BaseTreeNode(props);
    }
}
export function createTreeFromList(list, keySelector, parentKeySelector, valueMapper) {
    const map = createMapFromList(list, keySelector, valueMapper);
    const tree = [];
    list.forEach(row => {
        const id = keySelector(row);
        const parentId = parentKeySelector(row);
        const node = map.get(id);
        if (!node)
            return;
        if (parentId) {
            const parent = map.get(parentId);
            if (!parent)
                return;
            parent.children.push(node);
            parent.isLeaf = false;
            node.parent = parent;
        }
        else {
            tree.push(node);
        }
    });
    return tree;
}
export function createMapFromList(list, keySelector, valueMapper) {
    const map = new Map();
    list.forEach(row => map.set(keySelector(row), valueMapper(row)));
    return map;
}
export function createTreeNodeFilterCreator(key, mapperFn) {
    return (search) => {
        const regex = new RegExp('.*' + search + '.*', 'i');
        return function collectNodes(nodes, matches = []) {
            for (const node of nodes) {
                if (regex.test(mapperFn(node[key])))
                    matches.push(node);
                if (node.children.length)
                    collectNodes(node.children, matches);
            }
            return matches;
        };
    };
}
export function createGroupMap(list, othersGroupKey) {
    if (!isArray(list) || !list.some(node => Boolean(node.group)))
        return undefined;
    const mapGroup = new Map();
    for (const node of list) {
        const group = node?.group || othersGroupKey;
        if (typeof group !== 'string') {
            throw new Error(`Invalid group: ${group}`);
        }
        const items = mapGroup.get(group) || [];
        items.push(node);
        mapGroup.set(group, items);
    }
    return mapGroup;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS11dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvcmUvc3JjL2xpYi91dGlscy90cmVlLXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV6QyxpREFBaUQ7QUFDakQsTUFBTSxPQUFPLFlBQVk7SUFLdkIsWUFBWSxLQUFRO1FBSnBCLGFBQVEsR0FBa0IsRUFBRSxDQUFDO1FBQzdCLFdBQU0sR0FBRyxJQUFJLENBQUM7UUFJWixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQsTUFBTSxDQUFDLE1BQU0sQ0FBbUIsS0FBUTtRQUN0QyxPQUFPLElBQUksWUFBWSxDQUFJLEtBQUssQ0FBZ0IsQ0FBQztJQUNuRCxDQUFDO0NBQ0Y7QUFFRCxNQUFNLFVBQVUsa0JBQWtCLENBQ2hDLElBQVMsRUFDVCxXQUFpQyxFQUNqQyxpQkFBcUMsRUFDckMsV0FBMkI7SUFFM0IsTUFBTSxHQUFHLEdBQUcsaUJBQWlCLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUM5RCxNQUFNLElBQUksR0FBdUMsRUFBRSxDQUFDO0lBRXBELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDakIsTUFBTSxFQUFFLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzVCLE1BQU0sUUFBUSxHQUFHLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hDLE1BQU0sSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFekIsSUFBSSxDQUFDLElBQUk7WUFBRSxPQUFPO1FBRWxCLElBQUksUUFBUSxFQUFFO1lBQ1osTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNqQyxJQUFJLENBQUMsTUFBTTtnQkFBRSxPQUFPO1lBQ25CLE1BQWMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ25DLE1BQWMsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1lBQzlCLElBQVksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1NBQy9CO2FBQU07WUFDTCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2pCO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFFRCxNQUFNLFVBQVUsaUJBQWlCLENBQy9CLElBQVMsRUFDVCxXQUFpQyxFQUNqQyxXQUEyQjtJQUkzQixNQUFNLEdBQUcsR0FBRyxJQUFJLEdBQUcsRUFBYyxDQUFDO0lBQ2xDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pFLE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVELE1BQU0sVUFBVSwyQkFBMkIsQ0FDekMsR0FBWSxFQUNaLFFBQWdDO0lBRWhDLE9BQU8sQ0FBQyxNQUFjLEVBQUUsRUFBRTtRQUN4QixNQUFNLEtBQUssR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEdBQUcsTUFBTSxHQUFHLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztRQUVwRCxPQUFPLFNBQVMsWUFBWSxDQUFDLEtBQW9CLEVBQUUsVUFBeUIsRUFBRTtZQUM1RSxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtnQkFDeEIsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztvQkFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUV4RCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTTtvQkFBRSxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUNoRTtZQUVELE9BQU8sT0FBTyxDQUFDO1FBQ2pCLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLFVBQVUsY0FBYyxDQUM1QixJQUFtQixFQUNuQixjQUFzQjtJQUV0QixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFBRSxPQUFPLFNBQVMsQ0FBQztJQUVoRixNQUFNLFFBQVEsR0FBRyxJQUFJLEdBQUcsRUFBeUIsQ0FBQztJQUVsRCxLQUFLLE1BQU0sSUFBSSxJQUFJLElBQUksRUFBRTtRQUN2QixNQUFNLEtBQUssR0FBRyxJQUFJLEVBQUUsS0FBSyxJQUFJLGNBQWMsQ0FBQztRQUM1QyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtZQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLGtCQUFrQixLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQzVDO1FBRUQsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDeEMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqQixRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztLQUM1QjtJQUVELE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi9jb21tb24tdXRpbHMnO1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlcyAqL1xyXG5leHBvcnQgY2xhc3MgQmFzZVRyZWVOb2RlPFQgZXh0ZW5kcyBvYmplY3Q+IHtcclxuICBjaGlsZHJlbjogVHJlZU5vZGU8VD5bXSA9IFtdO1xyXG4gIGlzTGVhZiA9IHRydWU7XHJcbiAgcGFyZW50PzogVHJlZU5vZGU8VD47XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBUKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjcmVhdGU8VCBleHRlbmRzIG9iamVjdD4ocHJvcHM6IFQpIHtcclxuICAgIHJldHVybiBuZXcgQmFzZVRyZWVOb2RlPFQ+KHByb3BzKSBhcyBUcmVlTm9kZTxUPjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmVlRnJvbUxpc3Q8VCBleHRlbmRzIG9iamVjdCwgUj4oXHJcbiAgbGlzdDogVFtdLFxyXG4gIGtleVNlbGVjdG9yOiAoaXRlbTogVCkgPT4gTm9kZUtleSxcclxuICBwYXJlbnRLZXlTZWxlY3RvcjogdHlwZW9mIGtleVNlbGVjdG9yLFxyXG4gIHZhbHVlTWFwcGVyOiAoaXRlbTogVCkgPT4gUixcclxuKSB7XHJcbiAgY29uc3QgbWFwID0gY3JlYXRlTWFwRnJvbUxpc3QobGlzdCwga2V5U2VsZWN0b3IsIHZhbHVlTWFwcGVyKTtcclxuICBjb25zdCB0cmVlOiBOb2RlVmFsdWU8VCwgdHlwZW9mIHZhbHVlTWFwcGVyPltdID0gW107XHJcblxyXG4gIGxpc3QuZm9yRWFjaChyb3cgPT4ge1xyXG4gICAgY29uc3QgaWQgPSBrZXlTZWxlY3Rvcihyb3cpO1xyXG4gICAgY29uc3QgcGFyZW50SWQgPSBwYXJlbnRLZXlTZWxlY3Rvcihyb3cpO1xyXG4gICAgY29uc3Qgbm9kZSA9IG1hcC5nZXQoaWQpO1xyXG5cclxuICAgIGlmICghbm9kZSkgcmV0dXJuO1xyXG5cclxuICAgIGlmIChwYXJlbnRJZCkge1xyXG4gICAgICBjb25zdCBwYXJlbnQgPSBtYXAuZ2V0KHBhcmVudElkKTtcclxuICAgICAgaWYgKCFwYXJlbnQpIHJldHVybjtcclxuICAgICAgKHBhcmVudCBhcyBhbnkpLmNoaWxkcmVuLnB1c2gobm9kZSk7XHJcbiAgICAgIChwYXJlbnQgYXMgYW55KS5pc0xlYWYgPSBmYWxzZTtcclxuICAgICAgKG5vZGUgYXMgYW55KS5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0cmVlLnB1c2gobm9kZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB0cmVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWFwRnJvbUxpc3Q8VCBleHRlbmRzIG9iamVjdCwgUj4oXHJcbiAgbGlzdDogVFtdLFxyXG4gIGtleVNlbGVjdG9yOiAoaXRlbTogVCkgPT4gTm9kZUtleSxcclxuICB2YWx1ZU1hcHBlcjogKGl0ZW06IFQpID0+IFIsXHJcbikge1xyXG4gIHR5cGUgS2V5ID0gUmV0dXJuVHlwZTx0eXBlb2Yga2V5U2VsZWN0b3I+O1xyXG4gIHR5cGUgVmFsdWUgPSBOb2RlVmFsdWU8VCwgdHlwZW9mIHZhbHVlTWFwcGVyPjtcclxuICBjb25zdCBtYXAgPSBuZXcgTWFwPEtleSwgVmFsdWU+KCk7XHJcbiAgbGlzdC5mb3JFYWNoKHJvdyA9PiBtYXAuc2V0KGtleVNlbGVjdG9yKHJvdyksIHZhbHVlTWFwcGVyKHJvdykpKTtcclxuICByZXR1cm4gbWFwO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVHJlZU5vZGVGaWx0ZXJDcmVhdG9yPFQgZXh0ZW5kcyBvYmplY3Q+KFxyXG4gIGtleToga2V5b2YgVCxcclxuICBtYXBwZXJGbjogKHZhbHVlOiBhbnkpID0+IHN0cmluZyxcclxuKSB7XHJcbiAgcmV0dXJuIChzZWFyY2g6IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKCcuKicgKyBzZWFyY2ggKyAnLionLCAnaScpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiBjb2xsZWN0Tm9kZXMobm9kZXM6IFRyZWVOb2RlPFQ+W10sIG1hdGNoZXM6IFRyZWVOb2RlPFQ+W10gPSBbXSkge1xyXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcclxuICAgICAgICBpZiAocmVnZXgudGVzdChtYXBwZXJGbihub2RlW2tleV0pKSkgbWF0Y2hlcy5wdXNoKG5vZGUpO1xyXG5cclxuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIGNvbGxlY3ROb2Rlcyhub2RlLmNoaWxkcmVuLCBtYXRjaGVzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG1hdGNoZXM7XHJcbiAgICB9O1xyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHcm91cE1hcDxUIGV4dGVuZHMgeyBncm91cD86IHN0cmluZyB9PihcclxuICBsaXN0OiBUcmVlTm9kZTxUPltdLFxyXG4gIG90aGVyc0dyb3VwS2V5OiBzdHJpbmcsXHJcbikge1xyXG4gIGlmICghaXNBcnJheShsaXN0KSB8fCAhbGlzdC5zb21lKG5vZGUgPT4gQm9vbGVhbihub2RlLmdyb3VwKSkpIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gIGNvbnN0IG1hcEdyb3VwID0gbmV3IE1hcDxzdHJpbmcsIFRyZWVOb2RlPFQ+W10+KCk7XHJcblxyXG4gIGZvciAoY29uc3Qgbm9kZSBvZiBsaXN0KSB7XHJcbiAgICBjb25zdCBncm91cCA9IG5vZGU/Lmdyb3VwIHx8IG90aGVyc0dyb3VwS2V5O1xyXG4gICAgaWYgKHR5cGVvZiBncm91cCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGdyb3VwOiAke2dyb3VwfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGl0ZW1zID0gbWFwR3JvdXAuZ2V0KGdyb3VwKSB8fCBbXTtcclxuICAgIGl0ZW1zLnB1c2gobm9kZSk7XHJcbiAgICBtYXBHcm91cC5zZXQoZ3JvdXAsIGl0ZW1zKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBtYXBHcm91cDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVHJlZU5vZGU8VCBleHRlbmRzIG9iamVjdD4gPSB7XHJcbiAgW0sgaW4ga2V5b2YgVF06IFRbS107XHJcbn0gJiB7XHJcbiAgY2hpbGRyZW46IFRyZWVOb2RlPFQ+W107XHJcbiAgaXNMZWFmOiBib29sZWFuO1xyXG4gIHBhcmVudD86IFRyZWVOb2RlPFQ+O1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgUm91dGVHcm91cDxUIGV4dGVuZHMgb2JqZWN0PiA9IHtcclxuICByZWFkb25seSBncm91cDogc3RyaW5nO1xyXG4gIHJlYWRvbmx5IGl0ZW1zOiBUcmVlTm9kZTxUPltdO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgTm9kZUtleSA9IG51bWJlciB8IHN0cmluZyB8IHN5bWJvbCB8IHVuZGVmaW5lZCB8IG51bGw7XHJcblxyXG5leHBvcnQgdHlwZSBOb2RlVmFsdWU8VCBleHRlbmRzIG9iamVjdCwgRiBleHRlbmRzICguLi5hcmdzOiBhbnkpID0+IGFueT4gPSBGIGV4dGVuZHMgdW5kZWZpbmVkXHJcbiAgPyBUcmVlTm9kZTxUPlxyXG4gIDogUmV0dXJuVHlwZTxGPjtcclxuIl19