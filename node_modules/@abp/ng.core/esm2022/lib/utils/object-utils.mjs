import { exists, isArray, isNode, isNullOrUndefined, isObject, isObjectAndNotArrayNotNode, } from './common-utils';
export function deepMerge(target, source) {
    if (isObjectAndNotArrayNotNode(target) && isObjectAndNotArrayNotNode(source)) {
        return deepMergeRecursively(target, source);
    }
    else if (isNullOrUndefined(target) && isNullOrUndefined(source)) {
        return {};
    }
    else {
        return exists(source) ? source : target;
    }
}
function deepMergeRecursively(target, source) {
    const shouldNotRecurse = isNullOrUndefined(target) ||
        isNullOrUndefined(source) || // at least one not defined
        isArray(target) ||
        isArray(source) || // at least one array
        !isObject(target) ||
        !isObject(source) || // at least one not an object
        isNode(target) ||
        isNode(source); // at least one node
    /**
     * if we will not recurse any further,
     * we will prioritize source if it is a defined value.
     */
    if (shouldNotRecurse) {
        return exists(source) ? source : target;
    }
    const keysOfTarget = Object.keys(target);
    const keysOfSource = Object.keys(source);
    const uniqueKeys = new Set(keysOfTarget.concat(keysOfSource));
    return [...uniqueKeys].reduce((retVal, key) => {
        retVal[key] = deepMergeRecursively(target[key], source[key]);
        return retVal;
    }, {});
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JqZWN0LXV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvbGliL3V0aWxzL29iamVjdC11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsTUFBTSxFQUNOLE9BQU8sRUFDUCxNQUFNLEVBQ04saUJBQWlCLEVBQ2pCLFFBQVEsRUFDUiwwQkFBMEIsR0FDM0IsTUFBTSxnQkFBZ0IsQ0FBQztBQUd4QixNQUFNLFVBQVUsU0FBUyxDQUN2QixNQUEwQixFQUMxQixNQUEwQjtJQUUxQixJQUFJLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxJQUFJLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQzVFLE9BQU8sb0JBQW9CLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0tBQzdDO1NBQU0sSUFBSSxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUNqRSxPQUFPLEVBQU8sQ0FBQztLQUNoQjtTQUFNO1FBQ0wsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFFLE1BQVksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0tBQ2hEO0FBQ0gsQ0FBQztBQUVELFNBQVMsb0JBQW9CLENBQzNCLE1BQTBCLEVBQzFCLE1BQTBCO0lBRTFCLE1BQU0sZ0JBQWdCLEdBQ3BCLGlCQUFpQixDQUFDLE1BQU0sQ0FBQztRQUN6QixpQkFBaUIsQ0FBQyxNQUFNLENBQUMsSUFBSSwyQkFBMkI7UUFDeEQsT0FBTyxDQUFDLE1BQU0sQ0FBQztRQUNmLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxxQkFBcUI7UUFDeEMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDO1FBQ2pCLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLDZCQUE2QjtRQUNsRCxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ2QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsb0JBQW9CO0lBRXRDOzs7T0FHRztJQUNILElBQUksZ0JBQWdCLEVBQUU7UUFDcEIsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFFLE1BQVksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0tBQ2hEO0lBRUQsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFnQyxDQUFDLENBQUM7SUFDbkUsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFnQyxDQUFDLENBQUM7SUFDbkUsTUFBTSxVQUFVLEdBQUcsSUFBSSxHQUFHLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQzlELE9BQU8sQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsRUFBRTtRQUMzQyxNQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsb0JBQW9CLENBQ3hDLE1BQWlDLENBQUMsR0FBRyxDQUFDLEVBQ3RDLE1BQWlDLENBQUMsR0FBRyxDQUFDLENBQ3hDLENBQUM7UUFDRixPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDLEVBQUUsRUFBTyxDQUFDLENBQUM7QUFDZCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBleGlzdHMsXHJcbiAgaXNBcnJheSxcclxuICBpc05vZGUsXHJcbiAgaXNOdWxsT3JVbmRlZmluZWQsXHJcbiAgaXNPYmplY3QsXHJcbiAgaXNPYmplY3RBbmROb3RBcnJheU5vdE5vZGUsXHJcbn0gZnJvbSAnLi9jb21tb24tdXRpbHMnO1xyXG5pbXBvcnQgeyBEZWVwUGFydGlhbCB9IGZyb20gJy4uL21vZGVscyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVlcE1lcmdlPFQ+KFxyXG4gIHRhcmdldDogRGVlcFBhcnRpYWw8VD4gfCBULFxyXG4gIHNvdXJjZTogRGVlcFBhcnRpYWw8VD4gfCBULFxyXG4pOiBEZWVwUGFydGlhbDxUPiB8IFQge1xyXG4gIGlmIChpc09iamVjdEFuZE5vdEFycmF5Tm90Tm9kZSh0YXJnZXQpICYmIGlzT2JqZWN0QW5kTm90QXJyYXlOb3ROb2RlKHNvdXJjZSkpIHtcclxuICAgIHJldHVybiBkZWVwTWVyZ2VSZWN1cnNpdmVseSh0YXJnZXQsIHNvdXJjZSk7XHJcbiAgfSBlbHNlIGlmIChpc051bGxPclVuZGVmaW5lZCh0YXJnZXQpICYmIGlzTnVsbE9yVW5kZWZpbmVkKHNvdXJjZSkpIHtcclxuICAgIHJldHVybiB7fSBhcyBUO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZXhpc3RzKHNvdXJjZSkgPyAoc291cmNlIGFzIFQpIDogdGFyZ2V0O1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVlcE1lcmdlUmVjdXJzaXZlbHk8VD4oXHJcbiAgdGFyZ2V0OiBEZWVwUGFydGlhbDxUPiB8IFQsXHJcbiAgc291cmNlOiBEZWVwUGFydGlhbDxUPiB8IFQsXHJcbik6IERlZXBQYXJ0aWFsPFQ+IHwgVCB7XHJcbiAgY29uc3Qgc2hvdWxkTm90UmVjdXJzZSA9XHJcbiAgICBpc051bGxPclVuZGVmaW5lZCh0YXJnZXQpIHx8XHJcbiAgICBpc051bGxPclVuZGVmaW5lZChzb3VyY2UpIHx8IC8vIGF0IGxlYXN0IG9uZSBub3QgZGVmaW5lZFxyXG4gICAgaXNBcnJheSh0YXJnZXQpIHx8XHJcbiAgICBpc0FycmF5KHNvdXJjZSkgfHwgLy8gYXQgbGVhc3Qgb25lIGFycmF5XHJcbiAgICAhaXNPYmplY3QodGFyZ2V0KSB8fFxyXG4gICAgIWlzT2JqZWN0KHNvdXJjZSkgfHwgLy8gYXQgbGVhc3Qgb25lIG5vdCBhbiBvYmplY3RcclxuICAgIGlzTm9kZSh0YXJnZXQpIHx8XHJcbiAgICBpc05vZGUoc291cmNlKTsgLy8gYXQgbGVhc3Qgb25lIG5vZGVcclxuXHJcbiAgLyoqXHJcbiAgICogaWYgd2Ugd2lsbCBub3QgcmVjdXJzZSBhbnkgZnVydGhlcixcclxuICAgKiB3ZSB3aWxsIHByaW9yaXRpemUgc291cmNlIGlmIGl0IGlzIGEgZGVmaW5lZCB2YWx1ZS5cclxuICAgKi9cclxuICBpZiAoc2hvdWxkTm90UmVjdXJzZSkge1xyXG4gICAgcmV0dXJuIGV4aXN0cyhzb3VyY2UpID8gKHNvdXJjZSBhcyBUKSA6IHRhcmdldDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGtleXNPZlRhcmdldCA9IE9iamVjdC5rZXlzKHRhcmdldCBhcyB7IFtrZXk6IHN0cmluZ106IGFueSB9KTtcclxuICBjb25zdCBrZXlzT2ZTb3VyY2UgPSBPYmplY3Qua2V5cyhzb3VyY2UgYXMgeyBba2V5OiBzdHJpbmddOiBhbnkgfSk7XHJcbiAgY29uc3QgdW5pcXVlS2V5cyA9IG5ldyBTZXQoa2V5c09mVGFyZ2V0LmNvbmNhdChrZXlzT2ZTb3VyY2UpKTtcclxuICByZXR1cm4gWy4uLnVuaXF1ZUtleXNdLnJlZHVjZSgocmV0VmFsLCBrZXkpID0+IHtcclxuICAgIChyZXRWYWwgYXMgYW55KVtrZXldID0gZGVlcE1lcmdlUmVjdXJzaXZlbHkoXHJcbiAgICAgICh0YXJnZXQgYXMgeyBba2V5OiBzdHJpbmddOiBhbnkgfSlba2V5XSxcclxuICAgICAgKHNvdXJjZSBhcyB7IFtrZXk6IHN0cmluZ106IGFueSB9KVtrZXldLFxyXG4gICAgKTtcclxuICAgIHJldHVybiByZXRWYWw7XHJcbiAgfSwge30gYXMgVCk7XHJcbn1cclxuIl19